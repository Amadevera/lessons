package LessonOne;
public class FirstLesson {
    // "ctrl + /" однострочный комментарий
    /*"ctrl + shift + /" - многострочный комментарий
     */
//    ctrl + alt + l - выравнивание кода (автоматическое проставление положенных отступов)
//   psv или psvm + enter - начать набирать == public static void main (String [] args) - точка входа.
    // точка входа - метод main - с этой точки начинается выполнение программы. одна на всю программу.
public static void main(String[] args) {
// sout + enter -  System.out.println();
System.out.println("FirstLesson");
//
//
//
///*
//
//Типы данных:
//1. примитивные типы
//2. ссылочные типы
//
//Примитивные типы переменных и количество памяти, которое выделяется пд тип, которое выделяется
//при создании переменной соответствующего типа.
//Объявление переменной - тип переменной с мал. букв, имя переменной с мал. букв, только латиница, без символов.
//если несколько слов - с мал буквы, без пробелов, каждое следующее слово с заглавной.
//называть нужно так, чтобы было понятно, что мы будем там хранить ех: login, pass
//можем сначала просто объявить, не присваивая значение.
// */
//
//
//        byte byteVar; //объявили
//        byteVar = 35; //присвоили значение (инициализировали)
//        byteVar = 12; //переопределили переменную (присвоили ей другое значение - убрали предыдущее, задали новое)
////можем сразу объявить и инициализировать. способ записи не влияет на скорость и память
////
//        byte byteVar2 = 10;
//        byte byteVar3, byteVar4; //через запятую можем объявлять несколько
//        byte bytevar5 = 12, byteVar6 = 22; //объявлять и инициализтровать тоже
//
////не может быть двух переменных с одним именем в рамках одной области видимости переменной. пока -
//// - в рамках одних фигурых скобок
//
///*Примитивы (8):
//Для хранения целых типов чисел (нужно знать объёмы памяти, диапазоны - не обязательно, кроме первых двух):
//1. byte хранение числовых данных от -128 до 127. Занимает 1 байт.
//Для передачи данных по сети, для хранения небольшого объёма данных.
//2. short хранение числовых данных от -32768 до 32767 (2 байта) (редкий)
//3. int (4 байта) (самый часто употребимый) +- 2млрд
//4. long (8 байт) +-18нулей
//*/
//        short shortVar = -155;
//        int intVar = 5340;
//        int intVar2 = 1_000_000;//intVar2 == intVar3 - никак не влияет на код.
//        int intVar3 = 1000000; // форма выше - только для нашего удобства при записи больших чисел.
//       // long longVar = 30000000000000000; //идея может выбать ошибку, если мы вышли за пределы int. решив, что здесь не long и мы просто ошиблись.
//        long longVar1 = 3000000000000000000L; //В этом случае добавляем в конце числа заглавную L (можно строчную, но легко спутать с единицей)
///*числа с плавающей точкой
//5. float (4 байта)
//6. double (8 байт) (предпочтительнее)*/
//        float floatVar = 5.7f; //обязательно указывать f иначе воспринмается программой как double
//        double doubleVar = 10.00; //предпочтительнее для плав. точки использвать double. под него больше оптимизация
////7. char (2 байта) - для хранения символов. (символьный тип данных)
//// Хранит номер символа таблицы юникода. Нет отрицательных значений. От 0 до 65535
//
////8. boolean - логический тип данных. Принимает только два значения: true/false.
//// Размер может отличаться в зависимости от машины и версии от 1 бита до 4 байтов
//        boolean trueVar = true;
//        boolean falseVar = false;
//
////Приведение типов (неявное):
//        byte someByte = 100; //если пытаемся присвоить значение больше диапазона - ошибка
//        int someInt = someByte; //неявное приведение - преобразоваие данных (не исходной переменной) к int, затем сохрание данных в переменную someInt
////доступно для совместивых типов. преобразование менее ёмкого типа в более ёмкий. увеличение контейнера ex: int -> long
////если типы несовместимы - никакого приведения
//
////Явное приведение таов (не тоько для примитивов):
//        someInt = 200;
////        someByte = someInt; //не произойдёт автоматической ковертации
//        someByte = (byte) someInt; //явное приведение. отбросятся старшие биты (отрежет правые биты), которые не умещаются - потеря значений и непредсказуемое поведение при преобразовании и приведении типов
////это может использоваться для экономии памяти. если точно уверены, что нам не придёт слишком большое (недопустимое0 значение.
//
////инструкции в коде отделяются одна от другой знаком ;
////среда выдаёт много подсказок
//
//
////дз: создать новый класс, объявлять переменные, присваивать значения. учиться создавать проекты и классы.
//
//            //операторы
//
//    //операторы присваивания:
//// = присвоить, += прибавтить и присвоить, -= отнять и присвоить, *= умножить и присвоить, /= разделить и присвоить, %= взять остаток от деления и присвоить
//someByte = 3;
//// someByte = someByte * 7; // подчёркивается, потому что int (см выше0, который мы будем пытаться положить в short
//someByte *= 7; //взять значение переменной, умножить на 7, затем новое, полученное, значение, присваиваем обратно переменной. Это не даст нам ошибку, в отличие от полной записи, хотя по смыслу полная и краткая запись идентичны. автоматическое приведение обратно к byte (в данном случае). Главное не потерять данные.
////в краткой записи будет автоматическое приведение типов, ошибку не выдаст. но есть шанс потерять данные, если выйдем за пределы диапазона.
//
//someInt = 10;
//someInt = someInt + 20;
//someInt += 20; //эта строка и строка выше абсолютно идентичны. полная и краткая запись.
//
//int a = 7;
//int b = 2;
//int c = a / b; //дробная часть просто отбрасываетяс при делении целых чисел. без округления.
//
////строгая типизация. всегда сначала тип, потом уже имяя и значение.
////не надо пытаться делать арифметические операции над несовместимыми типами. Это бессмысленно.
//
//    //арифметические:
////+ (сложение), - (вычитание), * (умножение), / (деление), % (взять остаток от деления. деление по целому)
//int ab = 10;
//int bb = 90;
//int cb = ab + bb;
//        System.out.println(cb); //100
//        System.out.println(9 % 3); //0 - ничего не осталось в остатке
//        System.out.println(9 % 2); //1 - взяли только остаток, отбросили целую часть
//short x = 56;
//short y = 77;
//  //short z = x + y; результат сложения byte или short автоматически приводятся к int. и это ошибка.
//byte t = 53;
//short l = 55;
//  //short f = t + l;
//int res = x + y; //способ избежать ошибки - сложить в переменную int или long. автоматическая защита от дурака - хочет приведения к более объёмному типу.
//long r = t + l;
//
//short z = (short) (x + y); //можно через явное приведение типов, если нам таки нужен дальше byte или short. будет ругаться, если не взять вычисление в круглые скобки, иначе будет пытаться привести каждое отдельное значение к short и ругаться, что это бессмысленное преобразование short в short
//   //деление на ноль целочисленных (любых) и с плавающей точкой (любых):
//        int n = 100;
//        double m = 200.6;
//                //int zeroDiv = n / 0; - целочисленное деление на ноль невозможно. приводит к ошибке и немедленному прекращению выполнения программы. дальше не пойдёт.
//        //System.out.println(zeroDiv); - Exception in thread "main" java.lang.ArithmeticException: / by zero - описание ошибки
////at FirstLesson.main(FirstLesson.java:111) - класс, где ошибка. метод с ошибкой. строка с ошибкой. по ссылке можно перейти на строку ошибки
////double zeroDiv2 = m / 0; // получаем +/- бесконечность. работать с ней дальше невозможно. никак. но ошибку программа не выдаст. пойдёт дальше, пока потом не споткнётся об эту бесконечность.
////        System.out.println(zeroDiv2);
////
//        //операторы сравнения (результат их работы всегда boolean - true/false):
//// <(левая часть меньше правой - true или false?), > (левая часть больше, чем правая), <= (меньше ли 1 чем второй), >= (больше или равно первый чем второй), != (неравно), == (равно)
////        System.out.println(6 < 22); //true
////        System.out.println(6 > 22); //false
////        System.out.println(55 <= 55); //true
////тернарный оператор ? - возвращает результат в зависимости от условия true/false
////        переменная = (условие) ? выражение  1 : выражени 2;
////        оператор проверяет истинность выражения. если true, то выражение 1, если false, то выражение 2
////    int k = 4;
////    int j = 8;
////    int result = (k < j) ? k + j : k - j; //int - потому что тернальный оператор возвращает нам рез-т выражения в инте (result - результат работы. здесь будет k + j)
////    // задача: дана переменная int, если значение переменной чётное, тернарный оператор возвращает рез-т
////    // деления этой переменной на 2 , в противном случае рез-т умножения на 2. рез-т вывести в консоль.
////    int v = 4;
////    int w = (v % 2 == 0) ? v / 2 : v * 2; //разобраться с оператором %. нам нужно true или false, остатком от деления мы получаем число 0 (т.к. чётное, делится на 2 без остатка), нужно сравнить с чем-то, чтобы получить true или false. выполняется последовательно. сначала берёт остаток от деления, затем сравнивает.)
////        System.out.println(w);
}
}
////
//
////д/з - читать лекции и презентации, разобраться, что такое jvm, jdk (что в себя включает),
//// чем отличаются jdk и jre (что это),
//// разобраться с оператором %. Примитивы, приведение, операторы. Учить, экспериментировать.)
//
////поиграться с созданием проектов. посмотреть ветвления.
