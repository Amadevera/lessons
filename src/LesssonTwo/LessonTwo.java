package LesssonTwo;

import java.util.Scanner;

public class LessonTwo {
    public static void main(String[] args) {
        //if else
        /*
        if (условие1 любой длины но boolean - проверяется на true/false) { если true,
        выполняется набор инструкций в фигурных скобках. если false, то инструкции в ф. скобках выше игнорируются.
        } else if (условие2){дополнительных else if может быть сколько угодно. внутри ф. скобок
        инструкции разделяем точкой с запятой, после ф. скобок точек с запятой не бывает.
        boolean по умолчанию false} else if (условие) {если условие 1 тру, то выполняются его инструкции, остальные условия не проверяются.
        если условие 1 фолс, то его инструкции игнорируются и мы попадаем на второе условие, если оно тру, то то же
        самое, что и в первом случае. Если предыдущее тру, последующие не проверяются. if может быть 1 сам по себе, к нему
        можно добавить сколько угодно else if
        } else {если все предыдущие условия фолс, то без каких-либо проверок выполнится элз.
        else дополняет конструкцию if, вне конструкции не существует.
        }

         */
        int state = 0;
        if (state == 0) {
            System.out.println("Закрытие приложения");
        } else if (state == 1) {
            System.out.println("Запуск приложения");
        } else {
            System.out.println("Ошибка статуса");
        }
//если инструкция к каждой ветке одна, то можно опустить фигкрные скобки.
/*
if (state == 0) System.out.println("Закрытие приложения");
else if (state == 1) System.out.println("Запуск приложения");
else System.out.println("Ошибка статуса");

*/

        //логические операторы - возвращают true/false
        // && и
        // || или
        // ! не
        // ^ исключающее или
        int state2 = 1;
        int code = 60;
        //       (state ==  0 && code > 100 ) //если первая часть false, то вторую не смотрит. ему важно, чтобы обе части были true
        int exp = 8;
        int age = 30;
//        (age > 30 || exp > 7) //true. Первая часть неверна, тогда проверяет - втора часть верна проверяет только одну часть выражения, если первая часть true, если нет - проверяет вторую. или - по крайней мере что-то одно должно быть true
        boolean isClosed = false;
//        !isClosed; //true
        // исключающее или ^ - или-или. Верно должно быть лишь одно из условий, но не оба сразу. Проверяет обе половины.
        //           (state == 0 ^ code < 100) //false

        //важно помнить про приоритеты. программа идёт в порядке понижения приоритета действий.
        //если есть сомнения в последовательности - ставим скобки
        //((state == 0 ^ code > 100) || (age > 90 && z > 0))

        int count = 60;
        if (count > 89 && count <= 100) {
            System.out.println("Правильных ответов 5");
        } else if (count < 90 && count > 59) {
            System.out.println("Правильных ответов 4");
        } else if (count < 60 && count >39) {
            System.out.println("Оценка 3");
        } else if (count < 40 && count >= 0) { //сначала сравниваем count с одним, потом с другим. отдельно
            System.out.println("Оценка 3");
        } else {
            System.out.println("Ошибка ввода"); //ошибку ввода можно ставить в начало, чтобы алгоритм сначала
        } //проверил не херня ли нанм пришла,  а потом уже выбирал оценку. но и так правильно.

            /*switch

     switch (переменная/выражение)
      case значение/выражение:
        инструкции;
        break;
      case значение2/выражение2:
      case значение3/выражение3:
        инструкции;
        break;
      case значение4/выражение4:
        инструкции;
        break;
      default:
        инструкции;
        break;
     }

     выражение (вычисляемое) или переменная. Они могут быть следующих типов:
     byte (Byte - класс обёртка), short (Short), char (Character), int (Integer), String, enum (перечисления)
Как работает switch: переменная(0) проверяется на совпадение с переменной1, если совпали - выполняются инструкции,
нет - переходит к сравнению со следующим кейсом, если не совпала ни с одним из кейсов - идёт в default
или до конца конструкции, если дефаулта нет. Если совпадение найдено - выполняются инструкции этого
кейса до первого break. Если в кейсе первого совпадения нет break, программа выполняет инструкции этого кейса
и идёт в следующий кейс уже НЕ сверяя переменные, выполняет все инструкции и так подорряд по всем кейсам,
 пока не дойдёт до break или до конца.
*/
        int sum = 10000;
        int code1 = 5698; //4653 - скидка 30% 5698, 5111 - 20. 6922, 6113, 6099 - 10.
int result;
        switch (code1){
            case 4653:
        result = (int) (sum * 0.7);
                System.out.println(result);
        break;

        case 5698:
        case 5111:
        result = (int) (sum * 0.8);
            System.out.println(result);
        break;

        case 6922:
        case 6113:
        case 6099:
            result = (int) (sum * 0.9);
            System.out.println(result);
        break;

        default:
            System.out.println(sum);
        break;
    }

            //Looping Statements - циклы
    //инкремент - увеличивает значение переменной на 1
    //декремент - уменьшает значение переменной на 1
//постфиксный инкремент х++   (возвращает значение потом увеличивает)
//префиксный инкремент ++х (увеличивает, потом возвращает значение)
//постфиксный декремент х--   (возвращает значение потом уменьшает)
//префиксный декремент --х (уменьшает, потом возвращает значение)

int a = 2;
int res = a++ - ++a + a++ + a++ + a;
        //  2  -  4 + 4  +  5  +  6 = 13. a++ сначала отдаёт результат, потом увеливает
        //  и мы видим его изменённым уже при следующем обращении
        // ++a - отдаёт сразу уже изменённый вариант
        // a++ + ++a - отдаёт в первом случае оригинальное значение, во втором случае уже изменённый (дважды) результат
        System.out.println(res);

        /* цикл while
   while (условие boolean - true/false) {
   инструкция в теле цикла - любая. Будут выполняться столько раз, пока условие истина
        }
         */
int w = 55;
while (w <= 78) {
    System.out.println(w); //System.out.println(w++); сначала выведет, потом увеличит
    w++;
}
/*
Scanner scanner = new Scanner(System.in); //считываем информацию с  клавиатуры
        //int num = scanner.nextInt();

        while (true) {
            System.out.println("Введите число");
            int num = scanner.nextInt();
            if (num == 0){
                System.out.println("");
                break;
            }
            int result1 = num + 2;
            System.out.println(num + "+ 2 = " + result1 );
        }
*/
/* Scanner scanner = new Scanner(System.in); //считываем информацию с  клавиатуры
int num = scanner.nextInt();
System.out.println("Введите число");

        while (true) {
            System.out.println("Введите число");
            num = scanner.nextInt();
            if (num == 0){
                System.out.println("");
                break;
            }
            int result1 = num + 2;
            System.out.println(num + "+ 2 = " + result1 );
        }
*/

/* do { //сначала выполняется (без проверки) условие do и только потом переходим к while
    инструкция в теле выполняется 1 раз;
    } while (условие); //проверяем, если истина, выполняем do ещё раз
 */

        Scanner scanner = new Scanner(System.in); //считываем информацию с  клавиатуры
        int num;

        do {System.out.println("Введите число");
            num = scanner.nextInt();
            int result1 = num + 2;
            if (num != 0) System.out.println(num + "+ 2 = " + result1);
        } while (num != 0); //do ... while одну итерацию в любом случае выполнит, даже если условие ложно
            //цикл for (команда  в идее fori) - обязательн
        for (int i = 0; i < 9; i++) { // инициализация, проверка условия, выполнение инструкции, увеличение (всегда после инструкции.
            // может быть несколько счётчиков через запятую,
            // может быть несколько условий через логические операторы
            // обязательно здесь условие ( ; ; ) - бесконечный цикл
    // дз - в диапазоне [1, 100](включительно). честно без других значений.
    //копировать строку в идее - ctrl d

        }

//импорт нужной библиоткеи - клик на необходимый класс и alt + enter

    }
}