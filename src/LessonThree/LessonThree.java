package LessonThree;

import java.util.Arrays;

public class LessonThree {
    public static void main(String[] args) {
        //Массивы - коллекции, упорядоченный набор данных определённого класса
/*
Элементы в массиве должно быть одного типа.
Длина массива задаётся при его  создании, изменить её нельзя. Ника, никогда.
Массив - это ссылочный тип данных. Т.е. объект.
Элементы в массиве хранятся под индексами, начиная с нуля.
[3, -7, 0, 26] Здесь лемент 3 хранится под индексом 0, -7 хранится под индексом 1. Длина массива - 4 элемента.

 Объявление массива:
 указываем тип_данных (какие элементы будем хранить в массиве, [], имя переменной
 int[] name;
 допустимо, но нежелательно объявлять: int name[];

Создание массива
Вариант 1: тип_данных[] name = new тип_данных[длина массива]; //будет заполнен значениями по умолчанию

Значение по умолчанию: для всех целых чисел - 0, для чисел с плавающей точкой - 0.0,
для boolean - false, для char ()- нулевой символ - '\u0000' (), для ссылочных - null
Вариант 2:  int[] ints2 =  {45, 98, 12, -88, 54, 8, -221};   - создаём массив и сразу кладём в него элементы.
Используются там, где мы знаем количество элементов и не нужна динамика. Хранить и перебирать данные лучше в нём. Он легче и быстрее.
*/

        int[] ints1;
        ints1 = new int[3];
        int[] ints2 =  {45, 98, 12, -88, 54, 8, -221}; //просто присвоить одному массиву значение другого массива нельзя
        ints2 = new int[]{45, 12, 8,-221}; //но можем переприсвоить уже созданному массиву новое значение
 //при создании нового массива можем присвоить ему путь к уже занятой области памяти int[] ints3 = ints2; две ссылки на одну область памяти
 // доступ к элементам массива осуществляется по индексу: имя_массива[индекс]; (имя индекса в типе int)
        int ints2Elem = ints2[3]; //получить элемент из массива ints2 под индексом 3, присвоили его значение переменной
        ints2[1] = 4147; //обратились к массиву ints2 и перезаписали элемент с индексом 2. 12 заменили на 4147
//при обращении к несуществующему элементу массива программа выдаст исключение. Всегда. Программа закончит работу.

//размер массива - не меняем. длина неизменна. но можем получить её значение.
        System.out.println(ints2.length); //4 (ответ придёт в типе int)
//вывод элементов массива в консоль
        System.out.println(Arrays.toString(ints1));//класс Arrays имеет набор методов для работы с массивами
        System.out.println(Arrays.toString(ints2));

//перебор элементов массива
ints2 = new int[]{60, -80, 0, 200, 44};

//iter - краткий вывод для for (int i : имя_массива)
        for (int elem : ints2) { //тип данных элемнтов массива, любое имя переменной, оператор : для каждого элемента массива
            //на каждой итерации цикла переменной elem будет присваиваться значение следующего элемента массива
            // в данном цикле не можем изменить элементы массива. так как не обращаемся к массиву напрямую, только к elem
            System.out.println("elem = " + elem);
            elem *= 2;

            //краткий вызов для for - fori
            for (int i = 0; i < ints2.length; i++) { //не хардкодим длину массива.
                System.out.println("ints2[i] = " + ints2[i]); //i - даёт нам номер идекса в массиве
                ints2[i] = 90; //все элементы массива примут значение 90
            }
            System.out.println(Arrays.toString(ints2));
        }
//для сравнения массивов
       ints1 = new int[]{60, -80, 0, 200, 44};
       ints2 = new int[]{60, -80, 0, 200, 44};
        System.out.println(Arrays.equals(ints1, ints2)); //возвращает либо true - полностью идентичны
        // либо false - если длина разная, или разные элементы

        //методы класса Arrays: compare, compareUnsigned, mismatch
        //прочитать о них в документации на оракл, посмотреть по документац, потом в среде и в других источниках. поять как рабоают.

    //сортировка массива
        Arrays.sort(ints1); //передаём массив, кот хотим отсорировать, либо массив и диапазон индексов в нём.
        //Arrays.sort(ints1, from, to); от ("["включительно), до ("("исключительно). такой синтаксис,
        // нет опции включить верхнее значение. от меньшего к большему
        Arrays.parallelSort(ints2); //всем хорош, очень классный, но для больших массивов от 10 000 элеметов,
        // иначе бессмыслене. Большая трата ресурсов. не целесообразно. От меньшего к большему.

//поиск в отсортированном массиве
        //сначала отсортировать, потом искать в нём. с этим методом только так
        ints1 = new int[]{-90, -10, 0, 12, 45, 1231};
        System.out.println(Arrays.binarySearch(ints1, -10)); //1 вводим имя массива - где потом что - вернёт индекс
        System.out.println(Arrays.binarySearch(ints1, 89)); // -6 если не нашёл число - определяет, где оно могло бы стоять, добавляет 1 и минус
        System.out.println(Arrays.binarySearch(ints1, -91)); // -1 если не нашёл число - определяет, где оно могло бы стоять, добавляет 1 и минус
    }
}

//клик на метод и нажать ctrl клик мышкой - посмотреть реализацию метода (откроется в соседней вкладке)